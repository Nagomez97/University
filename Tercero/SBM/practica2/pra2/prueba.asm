;******************************************************************************* 
; CALCULA LA CODIFICACION HAMMING EDAC
;*******************************************************************************

; DEFINICION DEL SEGMENTO DE DATOS 

DATOS SEGMENT 

	MATRIZ  DB  1,0,0,1,  0,1,0,0,  0,0,1,0,  0,0,0,1,  1,1,0,1,  1,0,1,1,  0,1,1,1
   	ASCII  DB 	5 DUP (?)
   	NEW_VECTOR DB 4 DUP(0)
    BUFFER DB 5 DUP ('$') ; DOS BYTES PARA GUARDAR LA ENTRADA
    RESULTADO DB 3 DUP ('$')
    FIN DB "FIN",13,10,'$'
    ERROR DB "NUMERO INVALIDO",13,10,'$'


DATOS ENDS 


; DEFINICION DEL SEGMENTO DE PILA 

PILA SEGMENT STACK "STACK" 
    DB   40H DUP (0) 
PILA ENDS 


; DEFINICION DEL SEGMENTO EXTRA 

EXTRA     SEGMENT  

	VECTOR  DB	4 DUP (?) ; AQUI ALMACENAMOS EL VECTOR
	
EXTRA ENDS 


; DEFINICION DEL SEGMENTO DE CODIGO 

CODE    SEGMENT 
    ASSUME CS:CODE, DS:DATOS, ES: EXTRA, SS:PILA 

; COMIENZO DEL PROCEDIMIENTO PRINCIPAL 

START PROC 
  ;INICIALIZA LOS REGISTROS DE SEGMENTO CON SUS VALORES 
  MOV AX, DATOS 
  MOV DS, AX 

  MOV AX, PILA 
  MOV SS, AX 

  MOV AX, EXTRA 
  MOV ES, AX 

  ; CARGA EL PUNTERO DE PILA CON EL VALOR MAS ALTO 
  MOV SP, 64 

  ; FIN DE LAS INICIALIZACIONES 

  ;COMIENZO DEL PROGRAMA 

  ;INICIALIZAMOS NUESTRO VECTOR
  
  ; DECIMAL Y BINARIO DESDE TECLADO
  MOV AH, 0AH
  MOV DX, OFFSET BUFFER
  MOV BX, 0
  MOV BUFFER[BX], 3
  INT 21H


  MOV AH, 2H
  MOV DL, 13
  INT 21H
  MOV DL, 10
  INT 21H
  
  MOV AH, 9H
  MOV DX, OFFSET BUFFER
  ADD DX, 2
  INT 21H
  MOV CX, 0
  MOV CL, BUFFER[1] ; NUMERO DE CARACTERES LEIDOS

  MOV AH, 2H
  MOV DL, 13
  INT 21H
  MOV DL, 10
  INT 21H

  MOV DH, BUFFER[2] ; MOVEMOS A DX LOS DATOS LEIDOS (ASCII)
  MOV DL, BUFFER[3]

  CALL ASCII2INT ; TRANSFORMAR EL ASCII EN ENTERO

  MOV BX, AX

  CMP BX, 15
  JG ERRJ

  CALL INT2BIN ; TRANSFORMAR INT A BINARIO


  MOV AH, 9H
  MOV DX, OFFSET FIN
  INT 21H

FINAL:
  ; FIN DEL PROGRAMA 
  MOV AX, 4C00H 
  INT 21H

ERRJ:
  ; ERROR 
  MOV AH, 9H
  MOV DX, OFFSET ERROR
  INT 21H
  JMP FINAL

START ENDP 
;_______________________________________________________________ 
; SUBRUTINA PARA MULTIPLICAR UN VECTOR POR UNA MATRIZ 
; ENTRADA DX -> NUMERO EN ASCII (DH PRIMERA CIFRA, DL SEGUNDA CIFRA)
; SALIDA AX -> NUMERO EN DECIMAL (16 BITS)
;_______________________________________________________________ 
ASCII2INT PROC NEAR
  
  SUB DH, 30H
  SUB DL, 30H

  MOV AX, 10
  MUL DH
  MOV DH, 0 
  ADD AX, DX

  RET

ASCII2INT ENDP 

;_______________________________________________________________ 
; SUBRUTINA PARA MULTIPLICAR UN VECTOR POR UNA MATRIZ 
; ENTRADA BX -> NUMERO EN DECIMAL 
; SALIDA DS:NEW_VECTOR GUARDARA EL RESULTADO
;_______________________________________________________________ 
INT2BIN PROC NEAR
  MOV AX, BX
  MOV CX, 4 ; POSICION EN EL VECTOR

DIVI:
  DEC CX
  MOV BX, 2
  MOV DX, 0
  DIV BX ; DIVIDIMOS AX ENTRE 2 PARA IR SACANDO EL MODULO DE CADA DIGITO  
  ; AX CONTIENE EL COCIENTE Y DX CONTIENE EL RESTO (COMO ES MODULO 2, EL RESTO SE ALMACENARA EN DL)
  MOV BX, CX
  MOV NEW_VECTOR[BX], DL
  CMP AX, 0
  JNZ DIVI

  RET

INT2BIN ENDP

; FIN DEL SEGMENTO DE CODIGO 
CODE ENDS 
; FIN DEL PROGRAMA INDICANDO DONDE COMIENZA LA EJECUCION 
END START 