;******************************************************************************* 
; CALCULA LA CODIFICACION HAMMING EDAC
;*******************************************************************************

; DEFINICION DEL SEGMENTO DE DATOS 

DATOS SEGMENT 

	MATRIZ  DB  1,0,0,0,  0,1,0,0,  0,0,1,0,  0,0,0,1,  1,1,0,1,  1,0,1,1,  0,1,1,1 ; MATRIZ TRASPUESTA
    RESULTADO  DB   7 DUP (?) ; RESULTADO DE LA MULTIPLICACION DE MATRIZ
    PARITY DB 7 DUP (?) ; ALMACENARA EL RESULTADO CON LOS BITS DE PARIDAD EN SU POSICION
    NEW_VECTOR DB 0,0,0,0 ; VECTOR DE ENTRADA (DATO DE LA MULTIPLICACION)
    BUFFER DB 8 DUP ('$') ; DOS BYTES PARA GUARDAR LA ENTRADA
    EXIT DB "EXIT" ; PARA COMPROBAR QUE SEA EXIT
    ; STRINGS DE IMPRESION
    INPUT DB "INPUT: ",'$'
    OUTPUT DB "OUTPUT: ",'$'
    COMPUTATION DB "COMPUTATION:",13,10,'$'
    LINE DB 9,"| P1",9,"| P2",9,"| D1",9,"| P3",9,"| D2",9,"| D3",9,"| D4",13,10,'$'
    WRD_LINE DB 7 DUP ('?')
    P1_LINE DB 7 DUP (' ')
    P2_LINE DB 7 DUP (' ')
    P3_LINE DB 7 DUP (' ')
    WRD DB "WORD",9,'$'
    P1 DB "P1",9,'$'
    P2 DB "P2",9,'$'
    P3 DB "P3",9,'$'
    INTRODUZCA DB "INTRODUZCA UN NUMERO ENTRE 0 Y 15: ", '$'
    ERROR DB "NUMERO INVALIDO",13,10,'$'
    GOODBYE DB "GOODBYE",13,10,'$'

DATOS ENDS 


; DEFINICION DEL SEGMENTO DE PILA 

PILA SEGMENT STACK "STACK" 
    DB   40H DUP (0) 
PILA ENDS 


; DEFINICION DEL SEGMENTO EXTRA 

EXTRA     SEGMENT  

	VECTOR  DB 4 DUP (?) ; AQUI ALMACENAMOS EL VECTOR
	
EXTRA ENDS 


; DEFINICION DEL SEGMENTO DE CODIGO 

CODE    SEGMENT 
    ASSUME CS:CODE, DS:DATOS, ES: EXTRA, SS:PILA 

; COMIENZO DEL PROCEDIMIENTO PRINCIPAL 

START PROC 
    ;INICIALIZA LOS REGISTROS DE SEGMENTO CON SUS VALORES 
    MOV AX, DATOS 
    MOV DS, AX 

    MOV AX, PILA 
    MOV SS, AX 

    MOV AX, EXTRA 
    MOV ES, AX 

    ; CARGA EL PUNTERO DE PILA CON EL VALOR MAS ALTO 
    MOV SP, 64 

    ; FIN DE LAS INICIALIZACIONES 

    ; COMIENZO DEL PROGRAMA 
    
PROGRAMA:

	; PONEMOS TODO A SUS VALORES ORIGINALES
    MOV BX, 4
CEROS_N_V:
	DEC BX
    MOV NEW_VECTOR[BX], 0
   	CMP BX, 0
    JNZ CEROS_N_V

    MOV BX, 7
CEROS_R:
	DEC BX
    MOV PARITY[BX], 0
    MOV RESULTADO[BX], 0
    CMP BX, 0
    JNZ CEROS_R

    MOV BX, 8
DOLAR_B:	
	DEC BX
	MOV BUFFER[BX], '$'
	CMP BX, 0
	JNZ DOLAR_B

    ; IMPRIMIMOS CADENA PARA INTRODUCIR UN CARACTER

    MOV AH, 9H
  	MOV DX, OFFSET INTRODUZCA
  	INT 21H

	; LEEMOS NUESTRO NUMERO DESDE TECLADO
	MOV AH, 0AH ; FLAG DE LECTURA DESDE STDIN
 	MOV DX, OFFSET BUFFER 
  	MOV BX, 0
  	MOV BUFFER[BX], 5 ; NUMERO MAXIMO DE CARACTERES
  	INT 21H

  	MOV AH, 2H ; SALTO DE LINEA
  	MOV DL, 13
  	INT 21H
  	MOV DL, 10
  	INT 21H

  	; COMPROBAMOS QUE NO SEA EXIT
  	CALL STRCMP

  	CMP AX, 0 ; SI AX ES 0 ES QUE HA INTRODUCIDO EXIT
  	JZ FINAL

  	MOV CX, 0
  	MOV CL, BUFFER[1]

  	CMP CX, 3 ; COMPROBAMOS QUE NO SE HAYAN LEIDO MAS DE DOS CARACTERES
  	JNB ERRJ

  	CMP CX, 2
  	JNZ CAR1 ; SI TIENE UN SOLO CARACTER LEIDO

CAR2:
  	MOV DH, BUFFER[2] ; MOVEMOS A DX LOS DATOS LEIDOS (ASCII)
  	MOV DL, BUFFER[3]
  	JMP CONT ; CONTINUA EL PROGRAMA

CAR1:
	MOV DH, '0' ; 0 EN ASCII
	MOV DL, BUFFER[2]

CONT:
  	CALL ASCII2INT ; TRANSFORMAR EL ASCII EN ENTERO, LO DEVUELVE EN AX

  	MOV BX, AX

  	CMP BX, 16 ; VEMOS QUE NO SEA MAYOR QUE 15 (TRABAJAMOS SIN SIGNO)
  	JNB ERRJ


  	CALL INT2BIN ; TRANSFORMAR INT A BINARIO, LO GUARDA EN NEW_VECTOR

    ; RECIBIMOS EL VECTOR EN DX:BX
    MOV DH, NEW_VECTOR[0]
    MOV DL, NEW_VECTOR[1]
    MOV BH, NEW_VECTOR[2]
    MOV BL, NEW_VECTOR[3]
    ; POSTERIORMENTE ESTE CODIGO SERA SUSTITUIDO
    ; POR UNA ENTRADA DESDE TERMINAL	

    CALL MATMULT ; CALCULAMOS LA MULTIPLICACION

    CALL IMPRIMIR ; IMPRIME LOS DATOS

    JMP PROGRAMA ; VUELVE AL PRINCIPIO

FINAL:
  	; FIN DEL PROGRAMA 
  	MOV AH, 9H
  	MOV DX, OFFSET GOODBYE
  	INT 21H
  	MOV AX, 4C00H 
  	INT 21H

ERRJ:
  	; ERROR 
  	MOV AH, 9H
  	MOV DX, OFFSET ERROR
  	INT 21H
  	JMP PROGRAMA

START ENDP 


;_______________________________________________________________ 
; SUBRUTINA PARA COMPARA DOS STRINGS
; ENTRADA VARIABLE BUFFER
;         VARIABLE EXIT
; SALIDA AL: 1 SI SON DIFERENTES, 0 SI SON IGUALES
;_______________________________________________________________ 
STRCMP PROC NEAR
  
	MOV BX, 4

L:
	DEC BX

	MOV AL, BUFFER[BX+2] ; LOS DOS PRIMEROS DE BUFFER SON DE CONTROL
	MOV DL, EXIT[BX]

	CMP AL, DL ; COMPROBAMOS QUE SEAN IGUALES
	JNZ NEQ ; SALTAR A NOTEQUAL (NEQ)

	CMP BX, 0
	JNZ L

	MOV AX, 0 ; SON IGUALES
	RET

NEQ:
	MOV AX, 1 ; NO SON IGUALES
	RET

STRCMP ENDP 
;_______________________________________________________________ 
; SUBRUTINA PARA MULTIPLICAR UN VECTOR POR UNA MATRIZ 
; ENTRADA DX -> NUMERO EN ASCII (DH PRIMERA CIFRA, DL SEGUNDA CIFRA)
; SALIDA AX -> NUMERO EN DECIMAL (16 BITS)
;_______________________________________________________________ 
ASCII2INT PROC NEAR
  
  SUB DH, 30H
  SUB DL, 30H

  MOV AX, 10
  MUL DH ; MULTIPLICAMOS POR 10 LA PRIMERA CIFRA
  MOV DH, 0 
  ADD AX, DX ; Y SUMAMOS LA SEGUNDA CIFRA

  RET

ASCII2INT ENDP 

;_______________________________________________________________ 
; SUBRUTINA PARA MULTIPLICAR UN VECTOR POR UNA MATRIZ 
; ENTRADA BX -> NUMERO EN DECIMAL 
; SALIDA DS:NEW_VECTOR GUARDARA EL RESULTADO
;_______________________________________________________________ 
INT2BIN PROC NEAR
  MOV AX, BX
  MOV CX, 4 ; POSICION EN EL VECTOR

DIVI:
  DEC CX
  MOV BX, 2
  MOV DX, 0
  DIV BX ; DIVIDIMOS AX ENTRE 2 PARA IR SACANDO EL MODULO DE CADA DIGITO  
  ; AX CONTIENE EL COCIENTE Y DX CONTIENE EL RESTO (COMO ES MODULO 2, EL RESTO SE ALMACENARA EN DL)
  MOV BX, CX
  MOV NEW_VECTOR[BX], DL
  CMP AX, 0
  JNZ DIVI

  RET

INT2BIN ENDP

;_______________________________________________________________ 
; SUBRUTINA PARA IMPRIMIR LOS RESULTADOS DE LA MULTIPLICACION
;_______________________________________________________________ 

IMPRIMIR PROC NEAR 

    ; PRIMERO COLCAMOS LOS BITS DE PARIDAD EN SU LUGAR
    MOV BX, 0
    MOV SI, 4
    MOV AH, RESULTADO[SI]
    MOV PARITY[BX], AH
    MOV BX, 1
    MOV SI, 5
    MOV AH, RESULTADO[SI]
    MOV PARITY[BX], AH
    MOV BX, 2
    MOV SI, 0
    MOV AH, RESULTADO[SI]
    MOV PARITY[BX], AH
    MOV BX, 3
    MOV SI, 6
    MOV AH, RESULTADO[SI]
    MOV PARITY[BX], AH
    MOV BX, 4
    MOV SI, 1
    MOV AH, RESULTADO[SI]
    MOV PARITY[BX], AH
    MOV BX, 5
    MOV SI, 2
    MOV AH, RESULTADO[SI]
    MOV PARITY[BX], AH
    MOV BX, 6
    MOV SI, 3
    MOV AH, RESULTADO[SI]
    MOV PARITY[BX], AH
    ;_______________________________________________________________

    ; IMPRIMIMOS INPUT
    MOV DX, OFFSET INPUT
    MOV AH, 9
    INT 21H
    MOV CX, 4

    MOV SI, OFFSET NEW_VECTOR
    CALL PRINT_VECTOR

    ;_______________________________________________________________

    ; IMPRIMIMOS OUTPUT (PARITY) ORDENADO
    MOV DX, OFFSET OUTPUT
    MOV AH, 9
    INT 21H
    MOV CX, 7

    MOV SI, OFFSET PARITY
    CALL PRINT_VECTOR

    ;_______________________________________________________________

    ; IMPRIMIMOS COMPUTATION
    MOV DX, OFFSET COMPUTATION
    MOV AH, 9
    INT 21H

    ; IMPRIMIMOS LA PRIMERA LINEA
    MOV DX, OFFSET LINE
    INT 21H
    ;_______________________________________________________________

    ; RELLENAMOS WORD CON CODIGO ASCII
    MOV SI, 0
    MOV BH, VECTOR[SI]
    ADD BH, 30H
    MOV SI, 2
    MOV WRD_LINE[SI], BH 

    MOV SI, 1
    MOV BH, VECTOR[SI]
    ADD BH, 30H
    MOV SI, 4
    MOV WRD_LINE[SI], BH

    MOV SI, 2
    MOV BH, VECTOR[SI]
    ADD BH, 30H
    MOV SI, 5
    MOV WRD_LINE[SI], BH

    MOV SI, 3
    MOV BH, VECTOR[SI]
    ADD BH, 30H
    MOV SI, 6
    MOV WRD_LINE[SI], BH  

    ; IMPRIMIMOS LA SEGUNDA LINEA
    MOV DX, OFFSET WRD
    MOV AH, 9
    INT 21H

    MOV SI, OFFSET WRD_LINE
    CALL PRINT_LINE
    ;_______________________________________________________________

    ; RELLENAMOS P1 CON CODIGO ASCII
    MOV SI, 0
    MOV BH, PARITY[SI]
    ADD BH, 30H
    MOV SI, 0
    MOV P1_LINE[SI], BH 

    MOV SI, 0
    MOV BH, VECTOR[SI]
    ADD BH, 30H
    MOV SI, 2
    MOV P1_LINE[SI], BH

    MOV SI, 1
    MOV BH, VECTOR[SI]
    ADD BH, 30H
    MOV SI, 4
    MOV P1_LINE[SI], BH

    MOV SI, 3
    MOV BH, VECTOR[SI]
    ADD BH, 30H
    MOV SI, 6
    MOV P1_LINE[SI], BH  

    ; IMPRIMIMOS LA TERCERA LINEA
    MOV DX, OFFSET P1
    MOV AH, 9
    INT 21H

    MOV SI, OFFSET P1_LINE
    CALL PRINT_LINE
    ;_______________________________________________________________


    ; RELLENAMOS P2 CON CODIGO ASCII
    MOV SI, 1
    MOV BH, PARITY[SI]
    ADD BH, 30H
    MOV SI, 1
    MOV P2_LINE[SI], BH 

    MOV SI, 0
    MOV BH, VECTOR[SI]
    ADD BH, 30H
    MOV SI, 2
    MOV P2_LINE[SI], BH

    MOV SI, 2
    MOV BH, VECTOR[SI]
    ADD BH, 30H
    MOV SI, 5
    MOV P2_LINE[SI], BH

    MOV SI, 3
    MOV BH, VECTOR[SI]
    ADD BH, 30H
    MOV SI, 6
    MOV P2_LINE[SI], BH  

    ; IMPRIMIMOS LA CUARTA LINEA
    MOV DX, OFFSET P2
    MOV AH, 9
    INT 21H

    MOV SI, OFFSET P2_LINE
    CALL PRINT_LINE
    ;_______________________________________________________________


    ; RELLENAMOS P3 CON CODIGO ASCII
    MOV SI, 3
    MOV BH, PARITY[SI]
    ADD BH, 30H
    MOV SI, 3
    MOV P3_LINE[SI], BH 

    MOV SI, 1
    MOV BH, VECTOR[SI]
    ADD BH, 30H
    MOV SI, 4
    MOV P3_LINE[SI], BH

    MOV SI, 2
    MOV BH, VECTOR[SI]
    ADD BH, 30H
    MOV SI, 5
    MOV P3_LINE[SI], BH

    MOV SI, 3
    MOV BH, VECTOR[SI]
    ADD BH, 30H
    MOV SI, 6
    MOV P3_LINE[SI], BH  

    ; IMPRIMIMOS LA QUINTA LINEA
    MOV DX, OFFSET P3
    MOV AH, 9
    INT 21H

    MOV SI, OFFSET P3_LINE
    CALL PRINT_LINE
    ;_______________________________________________________________





    RET 
IMPRIMIR ENDP 

;_______________________________________________________________ 
; SUBRUTINA PARA IMPRIMIR UN VECTOR 
; ENTRADAS:
;   SI: OFFSET DEL VECTOR
;   CX: NUMERO DE ELEMENTOS DEL VECTOR
;_______________________________________________________________ 
PRINT_VECTOR PROC NEAR

PRINT:
    MOV AL, [SI]
    ADD AL, 30H ; TRANSFORMAMOS A ASCII
    MOV DL, AL
    MOV AH, 2H
    INT 21H

    INC SI

    DEC CX
    JNZ PRINT

    ; IMPRIMIMOS SALTO DE LINEA
    MOV DL, 13
    INT 21H

    MOV DL, 10
    INT 21H

    RET

PRINT_VECTOR ENDP

;_______________________________________________________________ 
; SUBRUTINA PARA IMPRIMIR UNA LINEA
; ENTRADAS:
;   SI: OFFSET DE LA LINEA
;_______________________________________________________________ 
PRINT_LINE PROC NEAR

    MOV CX, 7
    MOV AH, 2H

PRINT_LOOP:
    MOV DL, '|'
    INT 21H

    MOV DL, ' '
    INT 21H

    MOV DL, [SI]
    INT 21H

    MOV DL, 9 ; TABULAMOS
    INT 21H

    INC SI

    DEC CX
    JNZ PRINT_LOOP

    ; IMPRIMIMOS SALTO DE LINEA
    MOV DL, 13
    INT 21H

    MOV DL, 10
    INT 21H

    RET

PRINT_LINE ENDP

;_______________________________________________________________ 
; SUBRUTINA PARA MULTIPLICAR UN VECTOR POR UNA MATRIZ 
; ENTRADA DX:BX -> DATO (4 BYTES CORRESPONDIENTES AL VECTOR)
; SALIDA DX:AX -> RESULTADO (POSICION DE MEMORIA)
;_______________________________________________________________ 

MATMULT PROC NEAR 
    
    ; LO CARGAMOS EN VECTOR PARA FACILITAR ACCESO
    MOV VECTOR[0], DH
    MOV VECTOR[1], DL
    MOV VECTOR[2], BH
    MOV VECTOR[3], BL   

    MOV SI, 28 ; ITERA COLUMNAS

BUCLE1:

    MOV CX, 4 ; ITERA FILAS
    SUB SI, 4 ; SIGUIENTE COLUMNA
    MOV DX, 0 ; ALMACENA LA SUMA

BUCLE2:
	DEC CX ; SIGUIENTE ELEMENTO DE LA MATRIZ
	MOV BX, CX 
 	MOV AL, MATRIZ[BX][SI] ; CARGAMOS LA MATRIZ
 	MUL VECTOR[BX] ; MULTIPLICAMOS VECTOR X MATRIZ
 	ADD DX, AX ; ALMACENAMOS SUMANDO
 	CMP CX, 0
 	JNZ BUCLE2 ; BUCLE EN LA FILAS

 	MOV AX, SI
 	MOV BX, 04H
	DIV Bl ; DIVIDIMOS PARA INDEXAR EL RESULTADO, QUE ALMACENA COCIENTE EN AH, RESTO EN AL
	MOV BH, 1
    AND DL, BH ; RESULTADO MODULO 2
    MOV BX, AX
	MOV RESULTADO[BX], DL; ALMACENAMOS EL RESULTADO
 	CMP SI, 0
 	JNZ BUCLE1 ; BUCLE EN LAS COLUMNAS

FIN:
   	; SE DEVUELVE LA DIRECCION DE RESULTADO EN DX:AX
   	MOV DX, SEG RESULTADO
   	MOV AX, OFFSET RESULTADO
 
    RET 
MATMULT ENDP 

; FIN DEL SEGMENTO DE CODIGO 
CODE ENDS 
; FIN DEL PROGRAMA INDICANDO DONDE COMIENZA LA EJECUCION 
END START 